# Концепция приложения QNACF (фокусировка контекста)

## 1. Что это за приложение
QNACF — это минималистичное web-приложение в формате интерактивного квиза, которое помогает из туманной задачи получить сфокусированный список чётких шагов (чек-лист).  
Приложение само по себе очень простое: оно работает с файловой системой, где Cursor-агент создаёт и обновляет JSON-файлы вопросов и ответов.  
Web-интерфейс лишь красиво отображает эти файлы, а пользователь выбирает ответы и при необходимости дописывает свои комментарии.  

Задача — не «решить всё за пользователя», а построить прозрачный цикл:
- есть папка с файлами,
- агент пишет туда вопросы,
- пользователь выбирает/дописывает ответы через интерфейс,
- агент читает ответы и пишет новые вопросы,
- интерфейс следит за изменениями файлов и обновляется.

## 2. Зачем оно нужно
Главная цель — уменьшить недопонимание между человеком и ИИ при постановке задач.  
Приложение помогает «сфокусировать контекст»: задать правильные уточняющие вопросы, собрать плюсы/минусы, и шаг за шагом превратить исходный текст задачи в проверенный чек-лист:
- **чек-лист реализации** (что и как делать),
- **чек-лист бизнес-критериев приёмки** (как это должно выглядеть и работать).

## 3. Цикл работы
1. Пользователь пишет задание в `./QNACF/task.md`.
2. Агент создаёт первый вопрос в `./QNACF/questions/0001_question.json`.
3. Интерфейс видит новый файл, показывает вопрос и 2–5 вариантов ответов.
4. Пользователь выбирает вариант или пишет свой ответ.
5. Ответ сохраняется в `./QNACF/answers/0001_answer.json`.
6. Агент смотрит на этот файл, обновляет `focused_checklist.md` и создаёт новый вопрос.
7. Интерфейс обновляется и цикл повторяется.

Таким образом, приложение живёт вокруг файловой системы, а интерфейс — это «окно» для просмотра и участия.

## 4. Где хранятся файлы
- `./QNACF/task.md` — исходная постановка задачи.
- `./QNACF/questions/*.json` — вопросы агента.
- `./QNACF/answers/*.json` — ответы пользователя.
- `./QNACF/focused_checklist.md` — итоговый чек-лист.
- `./QNACF/state.json` — текущее состояние процесса.
- `./QNACF/reference/` — материалы и ссылки для справки.

## 5. Минимальная техническая рамка
- Запуск как минималистичное web-приложение на **Node.js**.
- Сервер слушает порт **8820**.
- Интерфейс на **HTML + TailwindCSS через CDN** (без сборки, чтобы всё было лёгким).
- Сервер может работать внутри **Docker-контейнера**.
- Интерфейс просто следит за файлами и обновляет данные, никаких сложных API пока не нужно.
- В будущем можно расширить (WebSocket, агентный вызов), но сейчас прототип должен быть максимально простым.

## 6. Интерфейс
Интерфейс — это квиз в минималистичном стиле:
- **Главная сцена (текущий вопрос):**
  - блок с вопросом крупным шрифтом,
  - карточки с вариантами ответов (плюсы/минусы, отметка «предпочтительно»),
  - поле для пользовательской конкретики,
  - кнопка «Подтвердить выбор».
- **Сайдбар (прогресс):**
  - список всех вопросов (с номерами и статусом — отвечен или нет),
  - возможность нажать на вопрос, чтобы открыть его детали в главной сцене.
- **Прогресс-бар или индикатор** (например: «Отвечено 3 из 10»).
- Минимум элементов, чистый светлый фон, акцент на тексте.

## 7. Задача для Cursor
Реализуй рабочий прототип QNACF:
- Сервер Node.js на порту 8820.
- Интерфейс HTML+Tailwind CDN.
- Файлы хранятся в ./QNACF (как описано выше).
- Интерфейс должен:
  - показывать список вопросов (по файлам в ./QNACF/questions/),
  - позволять выбрать один и открыть его содержимое,
  - отобразить варианты ответов и поля для ввода,
  - сохранять ответы в ./QNACF/answers/ в правильном формате JSON,
  - обновлять данные при изменении файлов.
- Минимум кода, максимум прозрачности.
- Подготовь также Dockerfile, чтобы приложение можно было запустить в контейнере.

Главное — сделать простой прототип с живым циклом «файл появился → интерфейс обновился → ответ сохранён → агент видит».

---

# НОВАЯ БОЕВАЯ ЗАДАЧА

## Нужно разработать систему артефактного проектирования

Артефактное проектирование — это подход к созданию программных систем, где каждый компонент рассматривается как самостоятельный артефакт с чётко определёнными границами, интерфейсами и жизненным циклом.

### Основные принципы:
1. **Изоляция** — каждый артефакт работает независимо
2. **Интерфейсы** — чётко определённые точки взаимодействия
3. **Жизненный цикл** — от создания до удаления
4. **Версионирование** — отслеживание изменений
5. **Зависимости** — явное описание связей между артефактами

### Цель:
Создать систему, которая позволит:
- Проектировать сложные системы как набор артефактов
- Управлять зависимостями между артефактами
- Отслеживать жизненный цикл каждого артефакта
- Автоматизировать развёртывание и обновление
- Обеспечить изоляцию и независимость компонентов

### Вопросы для проработки:
- Как структурировать артефакты?
- Как управлять зависимостями?
- Как обеспечить изоляцию?
- Как автоматизировать жизненный цикл?
- Как интегрировать с существующими системами?