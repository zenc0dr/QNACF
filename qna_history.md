# QNACF Диалог - Журнал

## Вопрос 1: Зачем нужно приложение QNACF?
**Выбрали вариант 1:** Автоматизировать процесс превращения туманных задач в чёткие чек-листы через структурированный диалог
**Почему:** Это и есть фокусировка контекста - превращение хаоса в структуру через диалог, используя интеллектуальные способности человека

## Вопрос 2: Как должен работать процесс QNACF?
**Выбрали вариант 2:** Итеративный процесс с возможностью возврата к предыдущим вопросам и корректировки ответов
**Уточнение:** Каждый новый вопрос = новый файл. Cursor создаёт файлы через скрипт-сервер/автоматизатор, который:
- Хранит структуру папок с вопросами/ответами
- Сам нумерует файлы
- Может чистить/управлять файлами по командам
- Работает как стандартизатор и автоматизатор
**Почему:** Гибкость + возможность уточнений, но с простой файловой структурой

## Вопрос 3: Какая должна быть структура файлов для хранения вопросов и ответов?
**Выбрали вариант 2:** Раздельные папки: `questions/` и `answers/` с одинаковой нумерацией
**Дополнение:** Простой механизм бэкапа файлов в архив с номером в папку `/backups`
**Почему:** Чёткое разделение вопросов и ответов, легко сопоставить, плюс безопасность через бэкапы

## Тезисы
- **core_script** на sh - интерфейс для взаимодействия с приложением
- Скрипт автоматизирует: поиск, создание файлов в нужных папках, нумерацию
- После выбора ответа в приложении → данные в JSON файл
- После каждого ответа → мини-резюме с обоснованием выбора
- JSON формат должен быть удобен для поиска через скрипт

## Вопрос 4: Какой формат JSON будет удобен для поиска через core_script?
**Выбрали вариант 2:** Структурированный с отдельными полями: `{"id": "001", "question": "...", "options": [...], "answer": 1, "summary": "...", "tags": ["server", "nodejs"], "timestamp": "..."}`
**Почему:** Точный поиск по полям, легко фильтровать - критично для core_script

## Вопрос 5: Как должен работать web-интерфейс приложения?
**Выбрали вариант 4:** Простой polling с файловым мониторингом на сервере
**Дополнение:** Всё в Docker контейнере - артефактное проектирование
- Своя папка с файлами + docker-compose.yaml
- Web-интерфейс для взаимодействия с файлами в папке
- Использование любых Linux инструментов и образов в Docker
**Почему:** Максимальная простота + надёжность + изоляция через Docker

## Вопрос 6: Какая архитектура Docker-контейнеров будет оптимальной?
**Выбрали вариант 2:** Два контейнера: Node.js сервер + отдельный контейнер для core_script (sh/python)
**Почему:** Разделение ответственности - один отвечает за представление, второй за интерфейс

## Вопрос 7: Как контейнеры должны общаться между собой?
**Выбрали вариант 1:** Через общую файловую систему (volume) - core_script пишет файлы, Node.js читает
**Почему:** Максимальная простота + файлы уже есть как основа системы

## Вопрос 8: Какой должен быть минимальный набор команд для core_script?
**Выбрали вариант 1:** Базовые CRUD операции: create_question, read_question, update_answer, delete_question
**Почему:** Нужны только команды создания файлов - чтение через Cursor tooling

## Вопрос 9: Как должен выглядеть итоговый чек-лист в TODOMAKE.md?
**Новое понимание:** Хранить в папках - `implementation_checklist/` и `acceptance_checklist/`
- Внутри папок: журнал (mapping_checklist.md) + файлы (0001_item.md)
- Журнал = заголовки, файлы = детали/код/текст
- Масштабируемость для накопления опыта
- Можно создать папки и журнал прямо сейчас для тестирования

## Вопрос 9 (переформулированный): Как назвать папки и файлы для чек-листов?
**Выбрали вариант 4:** `tasks/` + `criteria/` с файлами `task_001.md`
**Почему:** Описательные названия + понятная структура

## Вопрос 10: Готовы ли мы начать формировать TODOMAKE на основе собранной информации?
**Выбрали вариант 1:** Да, у нас достаточно информации для создания базового TODOMAKE
**Почему:** Можно начать реализацию, проверить понимание

## Финальная структура
- Создана папочная структура `TODO/tasks/` и `TODO/criteria/`
- Каждая папка содержит `mapping_checklist.md` (журнал) + детальные файлы
- Файлы перенесены в удобную структуру для масштабирования
- Документирован полный метод QNACF в `qnacf_method.md`
